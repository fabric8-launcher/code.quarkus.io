package io.quarkus.code.service

import io.quarkus.code.config.GitHubConfig
import io.quarkus.code.model.GitHubCreatedRepository
import io.quarkus.code.model.GitHubToken
import org.eclipse.jgit.api.Git
import org.eclipse.jgit.api.errors.GitAPIException
import org.eclipse.jgit.transport.UsernamePasswordCredentialsProvider
import org.kohsuke.github.GHCreateRepositoryBuilder
import org.kohsuke.github.GHFileNotFoundException
import org.kohsuke.github.GHRepository
import org.kohsuke.github.GitHubBuilder
import java.io.IOException
import java.io.UncheckedIOException
import java.nio.file.Path
import java.util.Objects.requireNonNull
import javax.enterprise.context.ApplicationScoped
import javax.inject.Inject


@ApplicationScoped
class GitHubService(internal val authService: GitHubOAuthService = GitHubOAuthService.newGitHubOAuthService()) {

    @Inject
    lateinit var config: GitHubConfig

    @Throws(UncheckedIOException::class)
    fun repositoryExists(token: String, repositoryName: String): Boolean {
        check(isEnabled()) { "GitHub is not enabled" }
        require(token.isNotEmpty()) { "token must not be empty." }
        require(repositoryName.isNotEmpty()) { "repositoryName must not be empty." }
        return try {
            val gitHub = GitHubBuilder().withOAuthToken(token).build()
            return gitHub.getRepository("${gitHub.myself.login}/$repositoryName") != null
        } catch (ghe: GHFileNotFoundException) {
            false
        } catch (ioe: IOException) {
            throw UncheckedIOException(String.format("Could not check if the repository '%s' already exists ", repositoryName), ioe)
        }
    }

    @Throws(UncheckedIOException::class)
    fun createRepository(token: String, repositoryName: String): GitHubCreatedRepository {
        check(isEnabled()) { "GitHub is not enabled" }
        require(token.isNotEmpty()) { "token must not be empty." }
        require(repositoryName.isNotEmpty()) { "repositoryName must not be empty." }
        val newlyCreatedRepo: GHRepository
        try {
            val gitHub = GitHubBuilder().withOAuthToken(token).build()
            val repositoryBuilder: GHCreateRepositoryBuilder = gitHub.createRepository(repositoryName)
            newlyCreatedRepo = repositoryBuilder
                    .description("Generated by code.quarkus.io")
                    .create()
        } catch (e: IOException) {
            throw UncheckedIOException(String.format("Could not create GitHub repository named '%s'", repositoryName), e)
        }
        return GitHubCreatedRepository(newlyCreatedRepo.ownerName, newlyCreatedRepo.httpTransportUrl)
    }

    fun push(ownerName: String, token: String, httpTransportUrl: String, path: Path) {
        check(isEnabled()) { "GitHub is not enabled" }
        require(token.isNotEmpty()) { "token must not be empty." }
        require(httpTransportUrl.isNotEmpty()) { "httpTransportUrl must not be empty." }
        require(ownerName.isNotEmpty()) { "ownerName must not be empty." }
        requireNonNull(path, "path must not be null.")

        try {
            Git.init().setDirectory(path.toFile()).call().use { repo ->
                repo.add().addFilepattern(".").call()
                repo.commit().setMessage("Initial commit")
                        .setAuthor("quarkusio", "no-reply@quarkus.io")
                        .setCommitter("quarkusio", "no-reply@quarkus.io")
                        .setSign(false)
                        .call()

                val pushCommand = repo.push()
                pushCommand.remote = httpTransportUrl
                pushCommand.setCredentialsProvider(UsernamePasswordCredentialsProvider(ownerName, token))
                pushCommand.call()
            }
        } catch (e: GitAPIException) {
            throw IllegalStateException("An error occurred while pushing to the git repo", e)
        }

    }

    fun fetchAccessToken(code: String, state: String): GitHubToken {
        check(isEnabled()) { "GitHub is not enabled" }
        val response = authService.getAccessToken(GitHubOAuthService.TokenParameter(config.clientId.get(), config.clientSecret.get(), code, state))
        if(response.containsKey("error")) {
            throw IOException("${response.getFirst("error")}: ${response.getFirst("error_description")}")
        }
        return GitHubToken(response.getFirst("access_token"), response.getFirst("scope"), response.getFirst("token_type"))
    }

    fun isEnabled() = config.clientId.filter(String::isNotBlank).isPresent && config.clientSecret.filter(String::isNotBlank).isPresent

}